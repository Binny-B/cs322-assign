Chapter 1

대규모 프로그래밍은 타르 구덩이와 같다. 
선사시대의 강력한 짐승들이 구덩이에 빠져간 것 처럼 대규모 프로그래밍 팀들도 그러했다.
여러 요인들이 상호작용하는 것 때문에 발전이 느려지고, 문제의 복잡성 때문에 본질을 파악하기도 어려워졌다.

프로그램이 유용하게 변해가는 과정은 다음과 같다

1. Program : 
가장 초기에 만들어지는 기본적인 프로그램.
2. Programming Product : 
다른 유저들도 이용할 수 있도록 일반적인 환경에서 사용 가능하게 만든 것
매우 많은 테스트 케이스가 필요하다.
3. Programming System :
입출력이 정확히 정의된 인터페이스가 필요하다
4. Programming Systems Product :
2, 3의 요소를 모두 갖춘 것. 이때부터 대규모 프로그램에 이용할 수 있는 것이 된다.

왜 프로그래밍이 재밌는가?

1. 무언가를 만드는 순수한 기쁨
2. 다른 사람에게 유용한 것을 만드는 즐거움
3. 복잡한 시스템이 적절히 맞물리는 것을 만드는 즐거움
4. 항상 배우는 즐거움
5. 다루기 쉬운 작업 환경에서 오는 즐거움

프로그래밍의 고통

1. 완벽하게 만들어져야 한다.
2. 다른 사람들이 목표와 자원, 정보를 제공한다. 개발자가 직접 모든 것을 통제할 수 없다
3. 프로그램 설계는 재밌지만, 버그를 제거하는 지루한 반복을 계속해야 한다
4. 제품을 완성하더라도 기술 발전이 더 빨라 구식화된다


Chapter 2

왜 대규모 프로젝트가 자주 실패할까?

1. 추정 기술이 제대로 발달하지 않았고, 노력 및 진행과정에서 혼동을 일으킨다
많은 프로그래머들은 낙관주의자다. '이번에는 실행될거야', '마지막 버그를 찾았어' 등
모든 것이 잘 진행될 것이라는 예측이 잘못된 것이다.
프로그램 구현은 물리적인 매체(컴퓨터 등)와 기본적인 아이디어(인간의)의 부족함 때문에 시간과 노력이 필요하다
우리는 때때로 물리적인 것을 탓하지 우리의 아이디어를 탓하지 않는다. 자부심 때문인 것 같다.

2. 진행 상황이 제대로 모니터링 되지 않는다.
Man-Month = 노력의 추정, 일정을 짜는 데 사용되는 단위로, 사람이 한 달동안 할 수 있는 일의 양
개발 비용은 확실히 인원 수 x 개월 수 로 정해지지만, 프로그램 개발 속도는 그렇지 않다.

몇몇 작업은 순차적인 제약이 걸린다. 이 때문에 많은 노력을 투입해도 아무 영향이 없을 수 있다.


3. 무엇보다 중요한 점은, 인력을 추가하는 것이다.
작업을 분할하는 것은 좋으나, 의사 소통에 드는 노력이 증가한다.
이에 따른 2가지 부담은 교육 / 상호 의사소통 이다.
교육은 작업자 수에 비례해 늘어난다.
상호 의사소통은 n(n-1)/2 에 비례한다.
의사소통에 들어가는 노력은 작업의 분할으로 얻는 이점보다 더 커지기도 한다.
따라서 인원 추가는 일정을 더 길어지게 만들기도 한다


프로그램 개발 도중 가장 큰 영향을 받는 것은 개별 부분의 디버깅 및 테스트이다.
저자가 대략적으로 낸 통계에 의하면,  
1/3은 계획 / 1/6은 코딩 / 1/4는 개별 테스트 / 1/4는 모든 시스템 테스트
정도의 시간이 걸린다.

대략적인 분석을 해보면, 계획을 세우고 디버깅 하는 데 매우 오랜 시간이 걸린다.
실제 코드를 짜는 작업은 그리 많은 시간을 소요하지 않는다


소프트웨어 디렉터들은 기한을 맞추기 위해 생산성, 버그 발생 등을 예측하는 규칙이 필요하다.
이것과 자신의 직감을 통해 대략적인 작업 구상을 완료해야 한다.

A,B,C,D 4개의 팀이 각각 1개월만에 작업을 끝내야 한다고 가정하자. 그런데 A 팀이 2개월만에 끝냈다
1) A팀의 작업에서만 1개월의 추가적인 노력이 필요했다
2) 처음부터 작업에 소요될 시간 추정에 실패했다. 모든 팀이 2개월이 걸릴 것이다.

이 두 경우 모두 제 시간 안에 프로젝트를 완료할 수는 없다. 사람을 더 투입한다면?
교육 시간과 의사소통 시간의 증가로 인해 더 많은 시간이 소요될 것이다.

Brooks's law를 단순화하자면, 지연된 소프트웨어 개발에 인력을 추가하는 것은 더 느려지는 결과를 만든다

이것은 Man-Month 의 미신에 정확히 반대되는 것이다.