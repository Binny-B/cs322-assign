chapter 3

<문제> 최고와 최저 프로그래머들의 차이는
생산성에서 약 10:1, 효율성에서 약 5:1 정도가 발생한다.

앞서 이야기하였던 것 처럼, 프로그램 개발에 인력이 많으면 더 안좋다.
따라서 프로그래밍 관리자들은 가장 유능한 일부 인력만 고용해야 한다.

10명 단위의 유능한 프로그래머들으로 구성된 팀이 가장 이상적이지만,
결국 인원 수가 부족하기 때문에 프로그램 개발에 10년 이상이 걸릴 수 있다.
이는 기술 발전 차이로 인해 개발한 프로그램이 쓸모없어질 수 있다.

Harlan Mills는 수술팀 조직 방안을 제안한다. 소수의 인원이 개발을 주도하고,
나머지 인원은 그 사람들의 효율성과 생산성에 필요한 모든 지원을 제공하는 방식이다.

프로그래밍 팀을 의사로 비유해보면 다음과 같다.

1. 수술 집도자, 외과의사 (=수석 프로그래머)
- 프로그램의 기능과 성능을 정의
- 프로그램 설계 / 코드 및 테스트 작성 / 문서화

- 구조적 프로그래밍 언어를 사용해야 하고 (<- 옛날 책이라 최신 프로그래밍 패러다임이 아닌 듯 하다)
- 컴퓨팅 시스템 접근에 능해야 하며
- 뛰어난 재능과 10년 이상의 경력
- 응용 지식 등이 필요하다

2. 부조종사, copilot (=보조 프로그래머)
- 프로그램 설계 단계에 참여, 사고/토론/평가 진행
- 다른 팀과 기능/인터페이스 논의
- 대체할 수 있는 설계를 연구

- 코드를 작성할 수 있으나 그것을 도맡을 책임은 가지지 않는다.
- 주 프로그래머가 부재 시 대신하여 활동한다.

3. 관리자
- 재정, 인사, 공간, 장비 등을 관리한다
- 조직의 행정 시스템을 활용함

- 보통 계약, 법적 문제를 전담한다. (다른 팀으로 떼어내도 괜찮긴 하다)

4. 편집자
- 프로그래머들의 작성한 문서를 검토
- 프로그램 작성 중 생기는 여러 버전을 관리
- 제작 과정을 감독

5. 비서 (2명)
- 관리자, 편집자 팀의 보조 인력

6. 프로그램 사무원
- 프로그래밍 도중 발생하는 모든 기술적/기능적인 것들을 기록/유지/관리
- 프로그램의 입력/출력 결과물을 관리
- 이전 기록을 시간 순서에 따라 보관

이 역할은 프로그램 실행 과정을 팀원 모두가 볼 수 있게 하고, 팀 자산으로 바꾼다.
프로그래머들을 사무적인 잡무에서 해방시키고, 소홀히 여겨지는 업무들을 체계화하여 작업 결과물을 향상시킨다.

7. 도구 제작자
- 파일 및 텍스트 편집, 디버깅 서비스 등 구축
- 프로그래밍에 사용되는 도구를 관리하고 업그레이드

8. 테스터
- 작성중인 프로그램의 일부를 테스트
- 전체를 테스트하기 위한 테스트케이스 모음

9. 언어-변호사
- 프로그래머가 작성한 코드를 해당 언어에 맞게 최적화
- 같은 코드를 더 효율적이도록 바꿈

이렇게 10명의 사람으로 팀을 구성하는 것이 가장 효율적이고 최소화된 형태이다.
10명 중 7명이 문제 해결에 참여하지만 프로그램은 1~2명의 산물이 된다.

전통적으로 구성된 팀에서는 각 사람들이 작업을 나누고 각 부분을 설계하고 구현한다.
또한 모든 구성원들이 동등하여 판단 차이에 대한 논의가 필수적이다. 

하지만 위 방법에서는 메인 프로그래머와 보조 프로그래머가 모든 설계와 구현을 담당하며
이해관계의 차이가 없고, 판단의 차이는 메인 프로그래머의 방향을 따르는 것으로 해결된다.
이와 같이 문제의 분할과 상하 관계를 통해 팀이 하나로 행동할 수 있게 한다.
나머지 구성원들은 세부적인 기능을 전문화시키는 역할으로 정하여 구성원들 간의 의사소통을 단순화한다.


chapter 16

늑대 인간이 무서운 이유는 갑자기 돌변하기 때문이다. 이를 잡기 위해서는 은탄(silver bullet)이 필요하다.
소프트웨어 공학도 마찬가지다. 마감 일정, 예산 초과, 제품 오류 등이 괴물로 변한다.
이 괴물을 잡는, 개발 가격을 낮추는 은탄이 있으면 좋겠지만 그런 것은 존재하지 않는다.

소프트웨어 시스템에서는 줄일 수 없는 속성이 있다.
1. 복잡성
요소들끼리 서로 비 선형적으로 상호작용하기에 요소를 추가하는 것을 복잡성을 빠르게 증가시킨다

2. 순응성
사람마다 만드는 인터페이스는 다른데, 보편적인 원리가 없기에 이에 순응해야 한다.

3. 변경 가능성
소프트웨어는 하드웨어에 비해 기능 변경이 쉽다. 기능 변경을 하지 않으면 뒤쳐진다.

4. 비가시성
소프트웨어 구조는 설계도처럼 가시적으로 나타내기 힘들다. 각 기능을 나타내는 그래프가 복잡하기 때문이다

이런 어려움을 해결하기 위해 다음과 같은 발전이 이루어졌다

1. 고수준 언어
소프트웨어의 생산성, 신뢰성, 단순성을 크게 향상
부가적인 복잡성을 많이 제거함

2. 컴파일러 및 IDE 등 도구
소프트웨어 개발에 편의성을 제공하여 더 빠르게 개발할 수 있게 됨

3. 통합 프로그래밍 환경
UNIX 등의 환경을 통해 둘 이상의 프로그램을 동시에 사용할 수 있게 됨

Silver bullet을 만들기 위해서는?

1. 고수준 언어의 발전
고수준 언어는 부차적인 복잡성을 제거해주지만, 전부 제거하지 않으며 작은 문제들을 남겨놓는다. 

2. 객체 지향 프로그래밍
객체 지향 프로그래밍은 다양한 data type을 허용하므로써 한 수준 더 높은 부차적 복잡성을 제거하였다. 

3. 인공 지능
인공지능이 스프트웨어 생산성과 품질에서 대대적인 발전을 가져올 수 있으나
소프트웨어 구축의 어려운 점은 결정하는 것이지 말하는 것이 이니다. 
AI는 말하는 것만 할 수 있다. 

4. 전문가 시스템
전문가 시스템으로 인터페이스 규칙 제시, 테스트 전략 조언, 버그 타입을 기억, 최적화 힌트 제시등을 수행할 수 있다. 
이는 경험 많은 프로그래머의 지혜를 경험 적은 프로그래머의 코드에 담아내는 역할을 해줄 수 있다.

5. '자동' 프로그래밍
자동프로그래밍은 주어진 설계 방향만 가지고 문제를 해결하는 프로그램을 만들어 내는것이다. 
그러나 이를 일반적인 소프트웨어 수준에서 해결하는 것은 매우 어렵다.

6. 그래픽 프로그래밍
VLSI 침 설계 같이 설계의 그래픽 표현은 설계에 매우 큰 도움을 주었으나
소프트웨어 설계는 그래픽으로 표현해도 그 의미를 기하학적으로 담아내기 힘들다.

7. 프로그램 검증
프로그램 검증은 강력한 디버깅 도구이지만, 결국 프로그램이 요구조건을 충족하는 것을 확증하는 것까지만 할 수 있다. 
프로그램 구축의 핵심은 디버깅하는 하는 것이다.

8. 환경과 도구
발전된 환경과 도구 사용은 생산성과 신뢰성에서 결실이 있겠지만, 이는 한계가 있다.

9. 워크스테이션
빠른 컴퓨터는 작업시간의 대부분을 프로그래머의 일과 생각하는 시간으로 대부분 채울 수 있다. 
그러나 이것이 소프트웨어 개발의 마법 같은 발전은 아닐 것이다.


1. 구매 vs 구축
가장 좋은 방법은 구축하지 않는것이다. 되도록이면 구매하자

2. 요구사항을 명확하게 하고, 빠르게 시제품을 만들자
고객은 자신이 원하는게 뭔지 잘 모른다. 
개발자와 고객이 같이 요구조건을 정립하고 이를 위한 시제품을 빠르게 만들어야 한다.

3. 시스템에 새로운 기능을 추가하여 성장시킬 것
단계적으로 개발하여 차근차근 기능을 추가하는게 복잡하지 않다

4. 훌륭한 프로그램 디자이너들
좋은 디자이너들은 근본적인 문제를 해결할 수 있다.
